"""
Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?
---------------------
This is equivalent to finding the minimal a such that Pa + Pb = Pc and Pb + Pc = Pd for some a,b <= c <= d
The first equation is satisfied when 3a^2 - a + 3b^2 - b = 3c^2 - c
Multiplying through by 12 and completing the square yields (6a - 1)^2 + (6b - 1)^2 = (6c - 1)^2 + 1
For the second equation, we get (6b - 1)^2 + (6c - 1)^2 = (6d - 1)^2 + 1, hence 2(6c - 1)^2 = (6d - 1)^2 + (6a - 1)^2
Then (6c - 1)^2 = (3a + 3d - 1)^2 + (3d - 3a)^2, so for some m > n of opposite parity and coprime, and k > 0, we have
    3d - 3a = k(m^2 - n^2),  3d + 3a - 1 = 2kmn,  6c - 1 = k(m^2 + n^2)
    From the last equation, m,n are opposite parity and coprime, so m^2 + n^2 is either 1 or 5 mod 6, and so k must be 5 or 1 mod 6, respectively
    From the first equation, m^2 - n^2 is divisible by 3, and so m,n are both indivisible by 3 and hence m^2 + n^2 = 5 mod 6, so k = 1 mod 6
    From the second equation, kmn - 1 is divisible by 3, so m = n = 1 mod 3 or m = n = 2 mod 3
    In order to have a > 0, we need 2mn > m^2 - n^2, so in particular, m < rn for r = 1 + sqrt(2)
        Thus the smallest m,n we can start with is m = 7 and n = 4
Substituting 6c - 1 = k(m^2 + n^2) and 6d - 1 = k(m^2 - n^2 + 2mn) gives us
    (6b - 1)^2 + k^2(m^2 + n^2)^2 = k^2(m^2 - n^2 + 2mn)^2 + 1
    (6b - 1)^2 = k^2(m^4 + n^4 + 4m^2n^2 + 4m^3n - 2m^2n^2 - 4mn^3) - k^2(m^4 + n^4 + 2m^2n^2) + 1
    (6b - 1)^2 = 4k^2mn(m^2 - n^2) + 1
"""
import math
import timeit
start = timeit.default_timer()

r = 1 + math.sqrt(2)
def pent(n):
    return n * (3 * n - 1) // 2

class Point:
    def __init__(self, x = 0, y = 0, z = 0):
        self.x = x
        self.y = y
        self.z = z
        self.update()

    def update(self):
        self.k = 6 * self.x + 1
        self.n = (3 * self.z + 2) // 2
        self.m = self.n + 6 * self.y + 3

    def step(self):
        if self.x == 0 and self.y == 0:
            self.x, self.z = self.z + 1, 0
        elif self.y == 0:
            self.x, self.y, self.z = self.x - 1, self.z + 1, 0
        else:
            self.y, self.z = self.y - 1, self.z + 1
        self.update()

    def convert(self):
        return self.k, self.m, self.n

    def a_value(self):
        k, m, n = self.k, self.m, self.n
        return (k * (2 * m * n - m**2 + n**2) + 1) // 6

done = False
best = math.inf
counter = Point()
while not done:
    k, m, n = counter.convert()
    if k > best and m == 4 and n == 1:
        done = True
    elif m > r * n or math.gcd(m,n) > 1 or counter.a_value() > best:
        counter.step()
    else:
        big = 4 * (k**2) * m * n * (m**2 - n**2) + 1
        test = math.isqrt(big)
        if test**2 == big and test % 6 == 5:
            candidate = (k * (2 * m * n - m**2 + n**2) + 1) // 6
            if candidate < best:
                best = candidate
        counter.step()
print(pent(best))

stop = timeit.default_timer()
print('Time: ', stop - start)
